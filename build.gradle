buildscript {
	repositories {
		mavenLocal()
		jcenter()
		maven {
			name "Fabric Repository"
			url 'https://maven.fabricmc.net'
		}
	}
	dependencies {
		classpath "cuchaz:enigma:0.14.1-local"
		classpath "net.fabricmc:stitch:0.2.1-local"
		classpath "commons-io:commons-io:2.6"
		classpath "com.google.guava:guava:28.0-jre"
		classpath 'de.undercouch:gradle-download-task:3.4.3'
		classpath 'net.fabricmc:tiny-remapper:+'
	}
}

plugins {
	id 'de.undercouch.download' version '3.4.3'
	id 'maven'
	id 'maven-publish'
}

def minecraft_version = "1.14.4"

def ENV = System.getenv()
// Fetch build number from Jenkins
def build_number = ENV.BUILD_NUMBER ?: "local"

def yarnVersion = "${minecraft_version}+build.$build_number"

repositories {
	mavenLocal()
	mavenCentral()
	maven {
		name "Fabric Repository"
		url 'https://maven.fabricmc.net'
	}
}

configurations {
	enigmaRuntime {
		resolutionStrategy {
			cacheDynamicVersionsFor 0, "seconds"
			cacheChangingModulesFor 0, "seconds"
		}
	}
	intermediary
}

dependencies {
	enigmaRuntime "net.fabricmc:stitch:0.2.1-local"
	enigmaRuntime "cuchaz:enigma:0.14.1-local"
	intermediary "net.fabricmc:intermediary:$minecraft_version"
	intermediary "net.fabricmc:intermediary:$minecraft_version:v2"
}

def setupGroup = "jar setup"
def yarnGroup = "yarn"
def buildMappingGroup = "mapping build"
def mapJarGroup = "jar mapping"
def mappingsDir = file("mappings")
def mappingsExportOfficialDir = file("mappings_official")
def cacheFilesMinecraft = file(".gradle/minecraft")
def tempDir = file(".gradle/temp")
def mergedFile = file("${minecraft_version}-merged.jar")
def intermediaryJar = file("${minecraft_version}-intermediary.jar")
def yarnJar = file("${minecraft_version}-yarn.jar")
def namedJar = file("${minecraft_version}-named.jar")
def versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")
def libraries = new File(cacheFilesMinecraft, "libraries")
def libs = new File("build/libs/")

import cuchaz.enigma.command.CheckMappingsCommand
import cuchaz.enigma.command.ComposeMappingsCommand
import cuchaz.enigma.command.ConvertMappingsCommand
import com.google.common.hash.Hashing
//import com.google.common.io.Files
import com.google.common.net.UrlEscapers
import groovy.io.FileType
import groovy.json.JsonSlurper
import net.fabricmc.stitch.commands.CommandMergeTiny
import net.fabricmc.stitch.commands.CommandProposeFieldNames
import net.fabricmc.stitch.commands.CommandReorderTiny
import net.fabricmc.stitch.commands.CommandRewriteIntermediary
import net.fabricmc.stitch.merge.JarMerger
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils
import org.apache.commons.io.FileUtils

import java.nio.charset.StandardCharsets
import java.nio.file.FileSystem
import java.nio.file.FileSystems
import java.util.zip.GZIPOutputStream
import net.fabricmc.stitch.commands.tinyv2.CommandReorderTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandMergeTinyV2
import net.fabricmc.stitch.commands.tinyv2.CommandProposeV2FieldNames
import java.nio.file.*


boolean validateChecksum(File file, String checksum) {
	if (file != null) {
		def hash = com.google.common.io.Files.asByteSource(file).hash(Hashing.sha1())
		def builder = new StringBuilder()
		hash.asBytes().each {
			builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
		}
		return builder.toString().equals(checksum)
	}
	return false
}

task downloadVersionsManifest {
	group = setupGroup
	//inputs.property "mc_ver", minecraft_version
	inputs.property "currenttime", new Date()
	def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
	outputs.file(manifestFile)
	doLast {
		logger.lifecycle(":downloading minecraft versions manifest")
		FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
	}
}

def getManifestVersion(File manifestFile, String minecraft_version) {
	def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile)) : null
	return manifest != null ? manifest.versions.stream().filter({it.id.equals(minecraft_version)}).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest) {
	group = setupGroup
	def manifestFile = downloadVersionsManifest.outputs.files.singleFile
	def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

	//have to grab the release time as there's a current timestamp on each element?!
	inputs.property "releaseTime", manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

	outputs.file versionFile

	doLast {
		manifestVersion = getManifestVersion(manifestFile, minecraft_version) //nb need to re-read here in case it didn't exist before
		if (manifestVersion.isPresent() || versionFile.exists()) {

			if (manifestVersion.isPresent()) {
				FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
			}
		} else {
			throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
		}
	}

}

task downloadMcJars(dependsOn: downloadWantedVersionManifest) {
	group = setupGroup
	inputs.files versionFile

	outputs.files(clientJar, serverJar)

	outputs.upToDateWhen {
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))
		return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
	}

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		//reload in case it changed
		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

		logger.lifecycle(":downloading minecraft jars")

		if (!clientJar.exists() || !validateChecksum(clientJar, version.downloads.client.sha1)) {
			logger.lifecycle(":downloading minecraft client")
			FileUtils.copyURLToFile(new URL(version.downloads.client.url), clientJar)
		}

		if (!serverJar.exists() || !validateChecksum(serverJar, version.downloads.server.sha1)) {
			logger.lifecycle(":downloading minecraft server")
			FileUtils.copyURLToFile(new URL(version.downloads.server.url), serverJar)
		}
	}
}

task extractIntermediary(type: TinyFileOutput) {
	group = buildMappingGroup

	def v1Input = configurations.intermediary.files[0]
	// hax
	def v2Input = configurations.intermediary.files[1]

	v1Output = new File(cacheFilesMinecraft.getPath(), "${minecraft_version}-intermediary.tiny")
	v2Output = new File(cacheFilesMinecraft.getPath(), "${minecraft_version}-intermediary-v2.tiny")

	FileSystems.newFileSystem(v1Input.toPath(), null).withCloseable {
		Path fileToExtract = it.getPath("mappings/mappings.tiny")
		try {
			Files.copy(fileToExtract, v1Output.toPath())
		} catch (Exception ignored) {
		} // fuck groovy

	}

	FileSystems.newFileSystem(v2Input.toPath(), null).withCloseable {
		Path fileToExtract = it.getPath("mappings/mappings.tiny")
		try {
			Files.copy(fileToExtract, v2Output.toPath())
		} catch (Exception ignored){}

	}
}



task mergeJars(dependsOn: downloadMcJars) {
	group = setupGroup
	inputs.files downloadMcJars.outputs.files.files
	outputs.file(mergedFile)

	doLast {
		logger.lifecycle(":merging jars")
		def client = inputs.files.files.find {it.name.endsWith("-client.jar")}
		def server = inputs.files.files.find {it.name.endsWith("-server.jar")}
		def merged = mergedFile

		if(merged.exists()){
			return
		}

		def jarMerger = new JarMerger(client, server, merged)
		jarMerger.merge()
		jarMerger.close()
	}

}

task downloadMcLibs(dependsOn: downloadWantedVersionManifest) {
	group = setupGroup
	inputs.files versionFile

	outputs.dir(libraries)

	outputs.upToDateWhen {false}

	doLast {
		if (!versionFile.exists()) {
			throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
		}

		def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile, StandardCharsets.UTF_8))

		logger.lifecycle(":downloading minecraft libraries")

		if (!libraries.exists()) {
			libraries.mkdirs()
		}

		version.libraries.each {
			def downloadUrl = it.downloads.artifact.url

			download {
				src downloadUrl
				dest new File(libraries, downloadUrl.substring(downloadUrl.lastIndexOf("/") + 1))
				overwrite false
			}
		}
	}
}

task invertIntermediary(dependsOn: extractIntermediary ,  type: TinyFileOutput) {
	group = buildMappingGroup
	def v1Input = extractIntermediary.v1Output
	def v2Input = extractIntermediary.v2Output

	v1Output = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-inverted.tiny")
	v2Output = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-inverted-v2.tiny")
	outputs.file(v1Output)
	outputs.file(v2Output)

	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":building inverted intermediary")

		String[] v1Args = [
		        v1Input.getAbsolutePath(),
			v1Output.getAbsolutePath(),
			"intermediary", "official"
		]

		String[] v2Args = [
				v2Input.getAbsolutePath(),
			v2Output.getAbsolutePath(),
			"intermediary", "official"
		]

		new CommandReorderTiny().run(v1Args)
		new CommandReorderTinyV2().run(v2Args)
	}
}

task patchIntermediary(dependsOn: [mergeJars, extractIntermediary]) {
	group = buildMappingGroup
	def intermediaryTinyInput = extractIntermediary.v1Output

	def outputFile = new File(cacheFilesMinecraft, "${minecraft_version}-intermediary-full.tiny")
	outputs.file(outputFile)

	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":patching intermediary")
		String[] args = [
			mergedFile.getAbsolutePath(),
			intermediaryTinyInput.getAbsolutePath(),
			outputFile.getAbsolutePath(),
			"--writeAll"
		]

		new CommandRewriteIntermediary().run(args)
	}
}

task mapIntermediaryJar(dependsOn: [downloadMcLibs, extractIntermediary, mergeJars]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(intermediaryJar)

	//Force the task to always run
	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":mapping minecraft to intermediary")
		def tinyInput =extractIntermediary.v1Output
		mapJar(intermediaryJar, mergedFile, tinyInput, libraries, "official", "intermediary")
	}
}

task setupYarn(dependsOn: mapIntermediaryJar) {
	group = yarnGroup
}

task yarn(dependsOn: setupYarn) {
	group = yarnGroup
	doLast {
		ant.setLifecycleLogLevel "WARN"
		ant.java(
			classname: 'cuchaz.enigma.Main',
			classpath: configurations.enigmaRuntime.asPath,
			fork: true,
			spawn: true
		) {
			jvmarg(value: "-Xmx2048m")
			arg(value: '-jar')
			arg(value: intermediaryJar.getAbsolutePath())
			arg(value: '-mappings')
			arg(value: mappingsDir.getAbsolutePath())
			arg(value: '-profile')
			arg(value: 'enigma_profile.json')
		}
	}
}

task checkMappings {
	group = buildMappingGroup
	inputs.dir mappingsDir
	doLast {
		logger.lifecycle(":checking mappings")

		String[] args = [
			mergedFile.getAbsolutePath(),
			mappingsDir.getAbsolutePath()
		]

		new CheckMappingsCommand().run(args)
	}
}

task buildYarnTiny(dependsOn: mergeJars, type: TinyFileOutput) {
	group = buildMappingGroup
	inputs.dir mappingsDir
	if (!libs.exists()) {
		libs.mkdirs()
	}

	v1Output = new File(tempDir, "yarn-mappings.tiny")
	v2Output = new File(tempDir, "yarn-mappings-v2.tiny")

	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":generating tiny mappings")

		String[] v1Args = [
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tiny:intermediary:named",
			v1Output.getAbsolutePath()
		]

		String[] v2Args = [
			"enigma",
			mappingsDir.getAbsolutePath(),
			"tinyv2:intermediary:named",
			v2Output.getAbsolutePath()
		]

		new ConvertMappingsCommand().run(v1Args)
		new ConvertMappingsCommand().run(v2Args)
	}
}

task mergeTiny(dependsOn: ["buildYarnTiny", "invertIntermediary"], type: TinyFileOutput) {
	group = buildMappingGroup
	def yarnTinyV1Input = buildYarnTiny.v1Output
	def intermediaryTinyV1Input = invertIntermediary.v1Output
	def yarnTinyV2Input = buildYarnTiny.v2Output
	def intermediaryTinyV2Input = invertIntermediary.v2Output

	def unorderedResultV1Mappings = new File(tempDir, "mappings-unordered.tiny")
	def unorderedResultV2Mappings = new File(tempDir, "mappings-unordered-v2.tiny")
	v1Output = new File(tempDir, "mappings.tiny")
	v2Output = new File(tempDir, "mappings-v2.tiny")
	outputs.file(v1Output)
	outputs.file(v2Output)

	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":merging yarn and intermediary")
		String[] argsV1 = [
			intermediaryTinyV1Input.getAbsolutePath(),
			yarnTinyV1Input.getAbsolutePath(),
			unorderedResultV1Mappings.getAbsolutePath(),
			"intermediary",
			"official"
		]

		String[] argsV2 = [
			intermediaryTinyV2Input.getAbsolutePath(),
			yarnTinyV2Input.getAbsolutePath(),
			unorderedResultV2Mappings.getAbsolutePath(),
			"intermediary",
			"official"
		]

		new CommandMergeTiny().run(argsV1)
		new CommandMergeTinyV2().run(argsV2)

		logger.lifecycle(":reordering merged intermediary")
		String[] reorderArgsV1 = [
			unorderedResultV1Mappings.getAbsolutePath(),
			v1Output.getAbsolutePath(),
			"official", "intermediary", "named"
		]

		String[] reorderArgsV2 = [
			unorderedResultV2Mappings.getAbsolutePath(),
			v2Output.getAbsolutePath(),
			"official", "intermediary", "named"
		]

		new CommandReorderTiny().run(reorderArgsV1)
		new CommandReorderTinyV2().run(reorderArgsV2)
	}
}

task tinyJar(type: Jar, dependsOn: mergeTiny) {
	group = buildMappingGroup
	outputs.upToDateWhen {false}
	archiveName = "yarn-${yarnVersion}.jar"
	destinationDir(file("build/libs"))
	classifier = ""
	from (mergeTiny.v1Output) {
		rename { "mappings/mappings.tiny" }
	}
}

task compressTiny(dependsOn: [tinyJar, mergeTiny], type: TinyFileOutput){
	group = buildMappingGroup
	def outputFile = new File(libs, "yarn-tiny-${yarnVersion}.gz")
	outputs.file(outputFile)
	v1Output = outputFile

	def inputFile = mergeTiny.v1Output

	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":compressing tiny mappings")

		def buffer = new byte[1024]
		def fileOutputStream = new FileOutputStream(outputFile)
		def outputStream = new GZIPOutputStream(fileOutputStream)
		def fileInputStream = new FileInputStream(inputFile)

		def length
		while ((length = fileInputStream.read(buffer)) > 0) {
			outputStream.write(buffer, 0, length)
		}

		fileInputStream.close()
		outputStream.finish()
		outputStream.close()
	}
}

clean.doFirst {
	delete tempDir, cacheFilesMinecraft
}

tasks.build.dependsOn "compressTiny"
tasks.build.dependsOn "tinyJar"

task mapYarnJar(dependsOn: [compressTiny, mapIntermediaryJar]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(yarnJar)

	//Force the task to always run
	outputs.upToDateWhen {false}

	doLast {
		logger.lifecycle(":mapping minecraft to yarn")

		File tinyInput = compressTiny.v1Output
		mapJar(yarnJar, intermediaryJar, tinyInput, libraries, "intermediary", "named")
	}
}

task exportMappingsOfficial(dependsOn: extractIntermediary) {
	def composeInput = extractIntermediary.v1Output

	doLast {
		logger.lifecycle(":exporting mappings")
		String[] args = [
			"tiny",
			composeInput.getAbsolutePath(),
			"enigma",
			file("mappings/").getAbsolutePath(),
			"enigma",
			file("mappings_official/").getAbsolutePath(),
			"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task importMappingsOfficial(dependsOn: invertIntermediary) {
	def composeInput = invertIntermediary.v1Output

	doLast {
		logger.lifecycle(":importing mappings")
		String[] args = [
			"tiny",
			composeInput.getAbsolutePath(),
			"enigma",
			file("mappings_official/").getAbsolutePath(),
			"enigma",
			file("mappings/").getAbsolutePath(),
			"right"
		]

		new ComposeMappingsCommand().run(args)
	}
}

task buildTinyWithEnum(dependsOn: "mergeTiny", type: TinyFileOutput) {
	group = buildMappingGroup
	def noEnum = mergeTiny.v1Output
	def namedWithEnum = new File(tempDir, "named-with-enum.tiny")
	v1Output = namedWithEnum

	outputs.file(namedWithEnum)
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":seeking auto-mappable fields")
		String[] argsPropose = [
			mergedFile.getAbsolutePath(), // must use official jar
			noEnum.getAbsolutePath(),
			namedWithEnum.getAbsolutePath()
		]

		new CommandProposeFieldNames().run(argsPropose)
	}
}

task mapNamedJar(dependsOn: [buildTinyWithEnum, mapIntermediaryJar]) {
	group = mapJarGroup
	inputs.files downloadMcLibs.outputs.files.files
	outputs.file(namedJar)

	//Force the task to always run
	outputs.upToDateWhen { false }

	doLast {
		logger.lifecycle(":mapping minecraft to named")

		mapJar(namedJar, intermediaryJar, buildTinyWithEnum.v1Output, libraries, "intermediary", "named")
	}
}




task v1UnmergedYarnJar(dependsOn: buildYarnTiny, type : Jar){
	def mappings = buildYarnTiny.v1Output
	group = "mapping build"
	outputs.upToDateWhen {false}
	archiveName = "unmerged-yarn-${yarnVersion}v1.jar"

	from (file(mappings)) {
		rename mappings.name, "mappings.tiny"
	}
	destinationDir (file("build/jars"))
}

task v2UnmergedYarnJar(dependsOn: buildYarnTiny, type : Jar){
	def mappings = buildYarnTiny.v2Output
	group = "mapping build"
	outputs.upToDateWhen {false}
	archiveName = "unmerged-yarn-${yarnVersion}v2.jar"

	from (file(mappings)) {
		rename mappings.name, "mappings.tiny"
	}
	destinationDir(file("build/jars"))
}


publishing {
	publications {
		maven(MavenPublication) {
			groupId 'net.fabricmc'
			artifactId "yarn"
			version yarnVersion

			artifact (compressTiny.v1Output) {
				classifier "tiny"
				builtBy compressTiny
			}
			artifact (tinyJar)
		}

		unmergedYarn(MavenPublication) {
			groupId 'net.fabricmc'
			artifactId "yarn-unmerged"
			version yarnVersion

			artifact(v1UnmergedYarnJar){
				classifier "v1"
			}

			artifact(v2UnmergedYarnJar){
				classifier "v2"
			}

		}
	}
	repositories {
		maven {
			url "http://mavenupload.modmuss50.me/"
			if (project.hasProperty('mavenPass')) {
				credentials {
					username 'buildslave'
					password project.getProperty('mavenPass')
				}
			}
		}
	}
}


void mapJar(File output, File input, File mappings, File libraries, String from, String to){
	if (output.exists()) {
		output.delete()
	}

	def remapper = TinyRemapper.newRemapper()
		.withMappings(TinyUtils.createTinyMappingProvider(mappings.toPath(), from, to))
		.renameInvalidLocals(true)
		.rebuildSourceFilenames(true)
		.build()

	try {
		def outputConsumer = new OutputConsumerPath(output.toPath())
		outputConsumer.addNonClassFiles(input.toPath())
		remapper.readInputs(input.toPath())

		libraries.eachFileRecurse(FileType.FILES) {file ->
			remapper.readClassPath(file.toPath())
		}
		remapper.apply(outputConsumer)
		outputConsumer.close()
		remapper.finish()
	} catch (Exception e) {
		remapper.finish()
		throw new RuntimeException("Failed to remap jar", e)
	}
}

class TinyFileOutput extends DefaultTask {
	@OutputFile File v1Output
	@OutputFile File v2Output
}
